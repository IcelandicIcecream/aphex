// Pure local file system storage adapter - no database operations
import { writeFile, mkdir, unlink, stat, readdir } from 'fs/promises';
import { join, dirname } from 'path';
import type {
	StorageAdapter,
	StorageConfig,
	UploadFileData,
	StorageFile
} from '../interfaces/storage.js';

const DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const DEFAULT_ALLOWED_TYPES = [
	'image/jpeg',
	'image/png',
	'image/webp',
	'image/gif',
	'image/avif',
	'application/pdf',
	'text/plain'
];

/**
 * Pure local file system storage adapter - only handles files
 */
export class LocalStorageAdapter implements StorageAdapter {
	readonly name = 'local';
	private config: Required<StorageConfig>;

	constructor(config: StorageConfig) {
		this.config = {
			basePath: config.basePath,
			baseUrl: config.baseUrl || '',
			maxFileSize: config.maxFileSize || DEFAULT_MAX_FILE_SIZE,
			allowedTypes: config.allowedTypes || DEFAULT_ALLOWED_TYPES,
			options: config.options || {}
		};
	}

	/**
	 * Generate unique filename preserving original name
	 */
	private async generateUniqueFilename(originalFilename: string): Promise<string> {
		const { name, ext } = this.parseFilename(originalFilename);
		let filename = originalFilename;
		let counter = 1;

		// Check if file exists on disk
		while (await this.fileExistsOnDisk(filename)) {
			filename = `${name} (${counter})${ext}`;
			counter++;
		}

		return filename;
	}

	/**
	 * Parse filename into name and extension
	 */
	private parseFilename(filename: string): { name: string; ext: string } {
		const lastDotIndex = filename.lastIndexOf('.');
		if (lastDotIndex === -1) {
			return { name: filename, ext: '' };
		}
		return {
			name: filename.substring(0, lastDotIndex),
			ext: filename.substring(lastDotIndex)
		};
	}

	/**
	 * Check if file exists on disk
	 */
	private async fileExistsOnDisk(filename: string): Promise<boolean> {
		try {
			const filePath = join(this.config.basePath, filename);
			await stat(filePath);
			return true;
		} catch {
			return false;
		}
	}

	/**
	 * Store a file and return storage info
	 */
	async store(data: UploadFileData): Promise<StorageFile> {
		// Validate file type
		if (!this.config.allowedTypes.includes(data.mimeType)) {
			throw new Error(
				`Invalid file type: ${data.mimeType}. Allowed types: ${this.config.allowedTypes.join(', ')}`
			);
		}

		// Validate file size
		if (data.size > this.config.maxFileSize) {
			throw new Error(
				`File too large: ${data.size} bytes. Maximum size: ${this.config.maxFileSize} bytes`
			);
		}

		// Generate unique filename
		const filename = await this.generateUniqueFilename(data.filename);
		const filePath = join(this.config.basePath, filename);

		// Store internal path only - URL will be generated by API with asset ID
		// This forces all access through /assets/{id} for proper authorization
		const url = ''; // Will be populated as /assets/{assetId}/{filename} by the API

		console.log('[LocalStorageAdapter] Storing file:', {
			filename,
			filePath,
			note: 'URL will be generated as /assets/{assetId}/{filename}',
			basePath: this.config.basePath
		});

		// Ensure storage directory exists
		await mkdir(dirname(filePath), { recursive: true });

		// Save file to disk
		await writeFile(filePath, data.buffer);

		return {
			path: filePath,
			url, // Empty - API will generate clean URL with asset ID
			size: data.size
		};
	}

	/**
	 * Read a file from storage
	 * Used by API endpoint to serve files
	 */
	async getObject(path: string): Promise<Buffer> {
		const { readFile } = await import('fs/promises');
		return await readFile(path);
	}

	/**
	 * Delete a file from storage
	 */
	async delete(path: string): Promise<boolean> {
		try {
			await unlink(path);
			return true;
		} catch (error) {
			console.warn('Could not delete file from disk:', error);
			return false;
		}
	}

	/**
	 * Check if file exists
	 */
	async exists(path: string): Promise<boolean> {
		try {
			await stat(path);
			return true;
		} catch {
			return false;
		}
	}

	/**
	 * Get public URL for a file path
	 */
	getUrl(path: string): string {
		// Extract filename from path and construct URL
		const filename = path.split('/').pop() || '';
		return `${this.config.baseUrl}/${encodeURIComponent(filename)}`;
	}

	/**
	 * Get storage information
	 */
	async getStorageInfo(): Promise<{ totalSize: number; availableSpace?: number }> {
		try {
			// Calculate total size of files in storage directory
			const files = await readdir(this.config.basePath);
			let totalSize = 0;

			for (const file of files) {
				try {
					const filePath = join(this.config.basePath, file);
					const stats = await stat(filePath);
					if (stats.isFile()) {
						totalSize += stats.size;
					}
				} catch {
					// Skip files that can't be read
				}
			}

			return { totalSize };
		} catch (error) {
			console.error('Error getting storage info:', error);
			return { totalSize: 0 };
		}
	}

	/**
	 * Health check - test if we can write to storage
	 */
	async isHealthy(): Promise<boolean> {
		try {
			const testFile = join(this.config.basePath, `health-check-${Date.now()}.tmp`);
			await mkdir(dirname(testFile), { recursive: true });
			await writeFile(testFile, 'health check');
			await unlink(testFile);
			return true;
		} catch (error) {
			console.error('Storage health check failed:', error);
			return false;
		}
	}
}
