{"version":3,"file":"utils-gGoUUMc2.js","sources":["../../../../../node_modules/.pnpm/@sveltejs+kit@2.43.2_@sveltejs+vite-plugin-svelte@6.2.0_svelte@5.39.5_vite@7.1.7_@types+node@_z3nnnilo4scrymezt6vewf7gtq/node_modules/@sveltejs/kit/src/runtime/utils.js"],"sourcesContent":["/** @import { RemoteFormIssue } from '@sveltejs/kit' */\n/** @import { StandardSchemaV1 } from '@standard-schema/spec' */\nimport { BROWSER } from 'esm-env';\n\nexport const text_encoder = new TextEncoder();\nexport const text_decoder = new TextDecoder();\n\n/**\n * Like node's path.relative, but without using node\n * @param {string} from\n * @param {string} to\n */\nexport function get_relative_path(from, to) {\n\tconst from_parts = from.split(/[/\\\\]/);\n\tconst to_parts = to.split(/[/\\\\]/);\n\tfrom_parts.pop(); // get dirname\n\n\twhile (from_parts[0] === to_parts[0]) {\n\t\tfrom_parts.shift();\n\t\tto_parts.shift();\n\t}\n\n\tlet i = from_parts.length;\n\twhile (i--) from_parts[i] = '..';\n\n\treturn from_parts.concat(to_parts).join('/');\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport function base64_encode(bytes) {\n\t// Using `Buffer` is faster than iterating\n\tif (!BROWSER && globalThis.Buffer) {\n\t\treturn globalThis.Buffer.from(bytes).toString('base64');\n\t}\n\n\tlet binary = '';\n\n\tfor (let i = 0; i < bytes.length; i++) {\n\t\tbinary += String.fromCharCode(bytes[i]);\n\t}\n\n\treturn btoa(binary);\n}\n\n/**\n * @param {string} encoded\n * @returns {Uint8Array}\n */\nexport function base64_decode(encoded) {\n\t// Using `Buffer` is faster than iterating\n\tif (!BROWSER && globalThis.Buffer) {\n\t\tconst buffer = globalThis.Buffer.from(encoded, 'base64');\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tconst binary = atob(encoded);\n\tconst bytes = new Uint8Array(binary.length);\n\n\tfor (let i = 0; i < binary.length; i++) {\n\t\tbytes[i] = binary.charCodeAt(i);\n\t}\n\n\treturn bytes;\n}\n\n/**\n * Convert `FormData` into a POJO\n * @param {FormData} data\n */\nexport function convert_formdata(data) {\n\t/** @type {Record<string, any>} */\n\tconst result = Object.create(null); // guard against prototype pollution\n\n\tfor (let key of data.keys()) {\n\t\tconst is_array = key.endsWith('[]');\n\t\tlet values = data.getAll(key);\n\n\t\tif (is_array) key = key.slice(0, -2);\n\n\t\tif (values.length > 1 && !is_array) {\n\t\t\tthrow new Error(`Form cannot contain duplicated keys â€” \"${key}\" has ${values.length} values`);\n\t\t}\n\n\t\t// an empty `<input type=\"file\">` will submit a non-existent file, bizarrely\n\t\tvalues = values.filter(\n\t\t\t(entry) => typeof entry === 'string' || entry.name !== '' || entry.size > 0\n\t\t);\n\n\t\tdeep_set(result, split_path(key), is_array ? values : values[0]);\n\t}\n\n\treturn result;\n}\n\nconst path_regex = /^[a-zA-Z_$]\\w*(\\.[a-zA-Z_$]\\w*|\\[\\d+\\])*$/;\n\n/**\n * @param {string} path\n */\nexport function split_path(path) {\n\tif (!path_regex.test(path)) {\n\t\tthrow new Error(`Invalid path ${path}`);\n\t}\n\n\treturn path.split(/\\.|\\[|\\]/).filter(Boolean);\n}\n\n/**\n * @param {Record<string, any>} object\n * @param {string[]} keys\n * @param {any} value\n */\nexport function deep_set(object, keys, value) {\n\tfor (let i = 0; i < keys.length - 1; i += 1) {\n\t\tconst key = keys[i];\n\t\tconst is_array = /^\\d+$/.test(keys[i + 1]);\n\n\t\tif (object[key]) {\n\t\t\tif (is_array !== Array.isArray(object[key])) {\n\t\t\t\tthrow new Error(`Invalid array key ${keys[i + 1]}`);\n\t\t\t}\n\t\t} else {\n\t\t\tobject[key] ??= is_array ? [] : Object.create(null); // guard against prototype pollution\n\t\t}\n\t\tobject = object[key];\n\t}\n\n\tobject[keys[keys.length - 1]] = value;\n}\n\n/**\n * @param {readonly StandardSchemaV1.Issue[]} issues\n */\nexport function flatten_issues(issues) {\n\t/** @type {Record<string, RemoteFormIssue[]>} */\n\tconst result = {};\n\n\tfor (const issue of issues) {\n\t\t/** @type {RemoteFormIssue} */\n\t\tconst normalized = { name: '', path: [], message: issue.message };\n\n\t\t(result.$ ??= []).push(normalized);\n\n\t\tlet name = '';\n\n\t\tif (issue.path !== undefined) {\n\t\t\tfor (const segment of issue.path) {\n\t\t\t\tconst key = /** @type {string | number} */ (\n\t\t\t\t\ttypeof segment === 'object' ? segment.key : segment\n\t\t\t\t);\n\n\t\t\t\tnormalized.path.push(key);\n\n\t\t\t\tif (typeof key === 'number') {\n\t\t\t\t\tname += `[${key}]`;\n\t\t\t\t} else if (typeof key === 'string') {\n\t\t\t\t\tname += name === '' ? key : '.' + key;\n\t\t\t\t}\n\n\t\t\t\t(result[name] ??= []).push(normalized);\n\t\t\t}\n\n\t\t\tnormalized.name = name;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * We need to encode `File` objects when returning `issues` from a `form` submission,\n * because some validators include the original value in the issue. It doesn't\n * need to deserialize to a `File` object\n * @type {import('@sveltejs/kit').Transporter}\n */\nexport const file_transport = {\n\tencode: (file) =>\n\t\tfile instanceof File && {\n\t\t\tsize: file.size,\n\t\t\ttype: file.type,\n\t\t\tname: file.name,\n\t\t\tlastModified: file.lastModified\n\t\t},\n\tdecode: (data) => data\n};\n"],"names":[],"mappings":"AAAA;AACA;;AAGY,MAAC,YAAY,GAAG,IAAI,WAAW;AACf,IAAI,WAAW;;;;","x_google_ignoreList":[0]}